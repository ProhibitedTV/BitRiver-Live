# Systemd units

These unit files are optional helpers for keeping BitRiver Live running on Ubuntu and Debian hosts. Complete the basic setup in the root [README](../../README.md) first so you have working API binaries and a viewer release extracted or pulled from the container registry.

## Prerequisites

- **BitRiver Live binary** – Download the release tarball that matches your deployment (for example `bitriver-live-linux-amd64.tar.gz`) and copy the `bitriver-live` binary into place, or build from source when testing local changes.
- **Viewer bundle** – Extract the `bitriver-viewer-<tag>.tar.gz` archive from the same release into `/opt/bitriver-viewer` (or another staging directory). It produces `.next/standalone/`, `.next/static/`, and `public/` assets ready to serve. You can also pull `ghcr.io/bitriver-live/bitriver-viewer:<tag>` and mount the directory into the container.
- **Sudo access** – You'll run a few `sudo` commands to create directories and register the units. The first command prompts for your password if you haven't used sudo recently.

## Install the services

1. Create application directories:
   ```bash
   sudo mkdir -p /opt/bitriver-live /opt/bitriver-viewer
   ```
   Expect sudo to prompt for your password the first time.
2. Copy the BitRiver Live binary you built earlier into place and make it executable:
   ```bash
   sudo install -m 0755 /path/to/bitriver-live /opt/bitriver-live/bitriver-live
   ```
   Replace `/path/to/bitriver-live` with the compiled file from the quickstart.
3. Copy the viewer files from the extracted release into `/opt/bitriver-viewer`:
   ```bash
   sudo rsync -av --delete /path/to/bitriver-viewer/.next/standalone/ /opt/bitriver-viewer/
   sudo rsync -av /path/to/bitriver-viewer/.next/static /opt/bitriver-viewer/.next/
   sudo rsync -av /path/to/bitriver-viewer/public/ /opt/bitriver-viewer/public/
   ```
   Adjust the paths if you staged the release elsewhere. When running the container image, mount `/opt/bitriver-viewer` as a volume instead of copying files.
4. Create `/opt/bitriver-live/.env` with your production settings for the Go API. The installer generated by the control centre is a good reference and usually includes keys such as `BITRIVER_LIVE_ADDR` and `BITRIVER_VIEWER_ORIGIN`.
5. Create `/opt/bitriver-viewer/.env` with viewer runtime settings. A minimal configuration looks like:
   ```ini
   NEXT_PUBLIC_API_BASE_URL=
   NEXT_VIEWER_BASE_PATH=/viewer
   PORT=3000
   HOSTNAME=0.0.0.0
   ```
6. Prepare ingest configuration directories and environment files. The defaults below match the Docker Compose bundle and mount the packaged configuration files from the release archive:

   ```bash
   sudo install -d -m 0755 /opt/bitriver-srs /opt/bitriver-srs-controller /opt/bitriver-ome /opt/bitriver-transcoder

   sudo tee /opt/bitriver-srs/.env >/dev/null <<'EOF'
SRS_IMAGE=ossrs/srs:5
SRS_CONTAINER_NAME=bitriver-srs
SRS_CONF_DIR=/opt/bitriver-live/deploy/srs/conf
SRS_RTMP_PORT=1935
SRS_API_PORT=1985
SRS_EXTRA_ARGS=
EOF

   sudo tee /opt/bitriver-srs-controller/.env >/dev/null <<'EOF'
SRS_CONTROLLER_IMAGE=ghcr.io/bitriver-live/bitriver-srs-controller:latest
SRS_CONTROLLER_CONTAINER_NAME=bitriver-srs-controller
SRS_CONTROLLER_HOST_PORT=1986
SRS_CONTROLLER_BIND=:1985
SRS_CONTROLLER_UPSTREAM=http://srs:1985/api/
SRS_CONTROLLER_TOKEN=REPLACE_ME
SRS_CONTROLLER_EXTRA_ARGS=
EOF

   sudo tee /opt/bitriver-ome/.env >/dev/null <<'EOF'
OME_IMAGE=airensoft/ovenmediaengine:0.15.10
OME_CONTAINER_NAME=bitriver-ome
OME_CONFIG=/opt/bitriver-live/deploy/ome/Server.xml
OME_HTTP_PORT=8081
OME_SIGNALING_PORT=9000
OME_EXTRA_ARGS=
EOF

   sudo tee /opt/bitriver-transcoder/.env >/dev/null <<'EOF'
TRANSCODER_IMAGE=ghcr.io/bitriver-live/bitriver-transcoder:latest
TRANSCODER_CONTAINER_NAME=bitriver-transcoder
TRANSCODER_HOST_PORT=9001
TRANSCODER_BIND=:9000
TRANSCODER_TOKEN=REPLACE_ME
TRANSCODER_PUBLIC_BASE_URL=https://cdn.example.com/hls
TRANSCODER_PUBLIC_DIR=/var/lib/bitriver-transcoder/public
TRANSCODER_EXTRA_ARGS=
EOF
   ```

   Adjust image tags, ports, and mount paths to match your topology. Add extra Docker flags by setting `*_EXTRA_ARGS`.
   The FFmpeg controller exits during startup if `TRANSCODER_PUBLIC_BASE_URL` (exported to `BITRIVER_TRANSCODER_PUBLIC_BASE_URL`) is missing, so configure it with the HTTP origin viewers can reach before enabling the unit.
7. (Optional) If you want to send API logs to `/opt/bitriver-live/logs/server.log`, create the directory and uncomment the `StandardOutput` and `StandardError` lines in `bitriver-live.service`.
8. Copy the systemd unit files into place and reload systemd:
   ```bash
   sudo install -m 0644 deploy/systemd/bitriver-live.service /etc/systemd/system/bitriver-live.service
   sudo install -m 0644 deploy/systemd/bitriver-viewer.service /etc/systemd/system/bitriver-viewer.service
   sudo install -m 0644 deploy/systemd/srs.service /etc/systemd/system/srs.service
   sudo install -m 0644 deploy/systemd/srs-controller.service /etc/systemd/system/srs-controller.service
   sudo install -m 0644 deploy/systemd/ome.service /etc/systemd/system/ome.service
   sudo install -m 0644 deploy/systemd/bitriver-transcoder.service /etc/systemd/system/bitriver-transcoder.service
   sudo systemctl daemon-reload
   ```
9. Enable and start the services:
   ```bash
   sudo systemctl enable --now srs.service
   sudo systemctl enable --now srs-controller.service
   sudo systemctl enable --now ome.service
   sudo systemctl enable --now bitriver-transcoder.service
   sudo systemctl enable --now bitriver-live.service
   sudo systemctl enable --now bitriver-viewer.service
   ```

The viewer unit depends on the control centre so that both start in the right order. The Go API proxies `/viewer` requests to the Next.js server, giving the admin SPA and public viewer a shared origin.

## Verify the services

Check that the services are running and healthy:

```bash
systemctl status srs.service
systemctl status srs-controller.service
systemctl status ome.service
systemctl status bitriver-transcoder.service
systemctl status bitriver-live.service
systemctl status bitriver-viewer.service
```

A green "active (running)" status confirms systemd launched the processes. Use `journalctl -u <unit>` to inspect logs if any service reports an error.
